В данном блоке мы познакомимся с автотестировнием фронтенда. В предыдущих курсе мы освоили бэкенд

************************ Тестирование UI ***********************************************

UI (user interface — пользовательский интерфейс) — является точкой
взаимодействия человека и продукта. Дизайн кнопок, полей ввода и т.д. —
это место, где пользователь взаимодействует с системой (GUI).

Тестирование интерфейса пользователя осуществляется вместе со следующими видами тестирования (UI):
1. Тестирование на соответствие стандартам графических интерфейсов (соответствие макету).
   Например, СКРИНШОТНОЕ тестирование - это когда мы сделали скриншот страницы и сделали метод, который сравнивает,
   то что у нас на скрине и на нашей странице (в java заходим на страницу одним методом и на вход загружаем
   скриншот нашей страницы, а    другому методу, говорим тоже самое и он сравнивает их), что выглядит один в один.
   Это не сложно, но нужно погружаться в тему каких то моков. Но данные скриншотные тесты не стабильные,
   постоянно падают. Если разраб, что то поменяет и на пиксель сдвинет, тест упадёт. Придётся его перезаливать

2. Тестирование с различными разрешениями экрана.
   В ручном режиме сложно протестировать все разрешения экрана. А для автотестирование, достаточно добавить
   одну строчку с другим разрешением.

3. Тестирование кроссбраузерности или совместимости с разными интернет браузерами и их версиями.
   Тоже самое, что и 2 пункт, но вместо разрешения экрана, применяем автотесты для разных браузеров

4. Тестирование локализованных версий: точность перевода (мультиязычность, мультивалютность), проверка длины названий
   элементов интерфейса и т.д..

5. Тестирование графического интерфейса пользователя на целевых устройствах (смартфоны, кпп, планшеты).
   Пункт аналогичен 2-му и 3 му пункту

************************ Тестирование UX ***********************************************
UX (user experience — пользовательский опыт) — это показатель удовлетворенности
пользователей удобством использования, доступности и удовольствия,
предоставляемого при взаимодействии пользователя и продукта.

Что такое тестирование юзабилити?
● Есть ли у вашего сайта, продукта, услуги практическое назначение? Чем больше пользы, тем больше клиентов.
● Может ли пользователь найти то, что ему нужно? Будь то информация или продукт. Сведения и объекты должны быть
доступными.
● Достаточно ли эмоций в вашем дизайне? Какие впечатления остаются у людей от изображений, индивидуальности,
брендинга и других элементов продукта? Не слишком ли их много?

************************ ПИРАМИДА ТЕСТИРОВАНИЯ:***********************************************
UI
API
UNIT

UI тесты не стабильны. Т.к. разраб кнопочку поменял цвет, тест упадёт. Кроме того, бывает, что страница
загружается не равномерно, а бывает что стенд ужасно медленный.

************************ HTML ***********************************************
HTML — стандартизированный язык разметки документов для
просмотра веб-страниц в браузере. Веб-браузеры получают
HTML документ от сервера по протоколам HTTP/HTTPS или
открывают с локального диска, далее интерпретируют код
в интерфейс, который будет отображаться на экране
монитора.

Он определяет содержание и структуру веб-контента. Другие технологии, помимо HTML, обычно используются для описания
внешнего вида/представления (CSS) или функциональности/поведения (JavaScript) веб-страницы.

Страница состоит из элементов.
HTML-элемент выделяется из прочего текста в документе с помощью "тегов", которые состоят из имени элемента окружённого "<" и
">". Имя элемента внутри тега не чувствительно к регистру. То есть, оно может быть написано в верхнем или нижнем регистре, или
смешано. Например, тег <title> может быть записан как <Title>, <TITLE>, или любым другим способом
ЭЛЕМЕНТ — это набор из тегов и содержания.
Элементы страницы находятся между открывающим тегом <HTML> и закрывающим </ HTML>. Элемент<html> называется корневым
элементом.

достаточно популярный тренажёр для изучения HTML, это code-basics
(https://code-basics.com/ru/languages/html/lessons/html-markup). Кроме того, по данной ссылке https://code-basics.com/ru
ещё много курсов (CSS и т.д.). Нам нужно знать хотябы на базовом уровне.
1. Должен быть открывающий <html> и закрывающий </html> тег. А внутри него должно быть остальное. Что имено:
<head> </head> - отдельно голова
<body> </body> - отдельно тело

Внутри head нет для нас ничего интересного, там информация для браузера. Внутри body можем писать нужный текст.
Также есть огромное количество тегов, которые влияют на внешний вид.

[//]: # (Тег абзац <p> Абзац 1 </p>)

[//]: # (<p> Абзац 1 </p>)

[//]: # (тег заголовок <h2> Андрей Александрович, привет!!! </h2>  )

[//]: # (<h1> Это мой сайт! </h1>)
************************ CSS ***********************************************
CSS — формальный язык описания внешнего вида документа,
написанного с использованием языка разметки (HTML). Также
может применяться к любым XML-документам

Стили текста, расположение блоков на странице, анимация, цвет — всё это описывается с помощью каскадных таблиц
стилей CSS на самом деле не является языком программирования. Это не язык разметки - это ЯЗЫК ТАБЛИЦЫ СТИЛЕЙ.
Это означает, что он позволяет применять стили выборочно к элементам в документах HTML.

ВАЖНО!!! CSS ОБЫЧНО ПИШУТ В ОТДЕЛЬНОМ ФАЙЛЕ, НО МОЖНО И ТАКЖЕ В ФАЙЛЕ с HTML. Потренироваться с CSS можно на
том же сайте https://code-basics.com/ru/languages/css/lessons/introduction и узнать какие есть свойства.
Самое простое наверное это цвет

Например, чтобы выбрать все элементы абзаца на HTML странице и изменить текст внутри них с чёрного на красный,
а также добавить им рамку, мы должны в голове <head> <style> .......</style> </head> написать этот CSS:

[//]: # (p {)

[//]: # (color: red;)

[//]: # (border: black solid)

[//]: # (})
Здесь, сначала указываем к какому элементу хотим применить свойство, а потом указываем свойство в формате
ключ : значение.

А что же делать, если у нас несколько абзацев "p", и мы хотим один из них оставить черным цветом, а второй
красным. Для того нужно каждому тегу абзац добавить класс и написать, например.
<p class='red-block'> Абзац 1</p>
Также после <style> необходимо через точку написать .red-block
Получаем следующий код:

[//]: # (<html>)

[//]: # (<head> )

[//]: # (  <style>)

[//]: # (.red-block {)

[//]: # (color: red;)

[//]: # (border: black solid;)

[//]: # (})

[//]: # (  </style>)

[//]: # (</head>)

[//]: # (<body> )

[//]: # (<h2> Андрей Александрович, привет!!! </h2>)

[//]: # (<h1> Это мой сайт! </h1>)

[//]: # ()
[//]: # (<p class='red-block'> Абзац 1</p>)

[//]: # (<p> Абзац 2</p>)

[//]: # ()
[//]: # (</body>)

[//]: # (</html>)

Если же захотим сделать одну рамку на 2 абзаца, для этого используем div. А для этого нужно наш класс
из абзаца применить в div и наш код будет выглядеть следующим образом

[//]: # (<html>)

[//]: # (<head> )

[//]: # (  <style>)

[//]: # (.red-block {)

[//]: # (color: red;)

[//]: # (border: black solid;)

[//]: # (})

[//]: # (  </style>)

[//]: # (</head>)

[//]: # (<body> )

[//]: # (<h2> Андрей Александрович, привет!!! </h2>)

[//]: # (<h1> Это мой сайт! </h1>)

[//]: # ()
[//]: # (<div class='red-block'>)

[//]: # (<p> Абзац 1</p>)

[//]: # (<p> Абзац 2</p>)

[//]: # (</div>)

[//]: # (</body>)

[//]: # (</html>)

************************ JavaScript ***********************************************
JavaScript язык программирования, который позволяет вам создать динамически
обновляемый контент, управляет мультимедиа, анимирует изображения,
впрочем, делает всё, что угодно.

В основу создания JavaScript была положена идея динамического управления объектами HTML-документов без
перезагрузки текущей страницы (так называемые бессерверные сценарии)
JavaScript — язык сценариев, или скриптов. Скрипт представляет собой программный код — набор инструкций, который
не требует предварительной обработки (например, компиляции) перед запуском. Код JavaScript интерпретируется движком
браузера во время загрузки веб-страницы. Интерпретатор браузера выполняет построчный анализ, обработку и
выполнение исходной программы или запроса.

************************ Selenium ***********************************************
Selenium - инструмент для автоматизации действий веб-браузера. Т.е. Selenium это не тесты, а инструмент.
Это значит, что можем использовать в автотестах. А для этого мы установим библиотеку Selenium и
будем писать код, который будет запускать браузер и выполнять там какие то действия - нажимать на кнопки,
вводить текст и т.д. А чтобы писать автотесты, установим junit. Т.е у нас будут вместе работать
Selenium и какие-то дополнительные тестовые библиотеки

А теперь теория:
У нас есть какой-либо браузер (например, Chrome). У него есть инструмент разработки (DevTools). Отмечу, что DevTools
это отдельное приложение, оно не связано с браузером. Браузер отдельно, DevTools отдельно. Даже с учетом
того, что их впоследстви объединили, это два разных компонента, они не связаны. Они общаются через API
(в данном случае, через CDP).

Но что если мы тот же сайт откроем в браузере Mozilla. Там есть тот же исструмент разработчика, но называется
по другому - консоль. Она похожа на DevTools, но отличается немного. У Mozilla своё API (marionette).

Получается у нас, у каждого браузера своё API и у каждого свой DevTools

У каждого браузера также есть свои драйвера (сервера), которые позволяют управлять браузером.
Это ChromeDriver и GeckoDriver (их можно скачать). Эти драйвера общаются с браузером с помощью того же протокола,
шлют запросы и получают ответы. После того, как скачаем, мы можес с помощью postman слать get, post запросы и т.д.
Т.е. те запросы которые прописаны в документации к Chrome https://chromedevtools.github.io/devtools-protocol/.
А что же значит, что драйвера позволяют управлять браузером? Это значит позволяют отправлять запросы которые
открывают браузер, перейти по URL, нажать на какой то конкретный элемент. Всё это можно выполнить развернув
наш драйвер и послав нужные запросы ч/з postman.
Всё вроде бы понятно, но в чём проблема? Через postman не удобно отправлять, легче браузер открыть
и сделать руками. Кроме того, если мы освоим CDP на Chrome, то для Mozilla нам нужно разбираться с marionette. 
Поэтому мы пишем код, по которому эти запросы отправляем. Понятно, что с нуля нас никто не заставит писать код.
Уже есть библиотеки, котрые за нас это сделают. А именно, selenium написал такой интерфейс WebDriver, такую 
однотипную API для всех браузеров, которая принимает наш запрос и сама определяет (ч/з if и switch ) с какого 
браузера он был отправлен  
Подробнее с документацией WebDriver можно познакомиться на сайте https://www.w3.org/TR/webdriver2/. Кроме того, 
на данном сайте описана документация на многие интерфейсы.