package WebElement;


import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.*;
import org.openqa.selenium.By;
import org.openqa.selenium.Point;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;

public class XpathAndCss { private WebDriver driver;

    @BeforeEach
    public void setUp() {
        ChromeOptions options = new ChromeOptions();
        options.setPageLoadStrategy(org.openqa.selenium.PageLoadStrategy.EAGER);
        driver = new ChromeDriver(options); // 1. Запускается драйвер 2. Драйвер запускает браузер
        driver.manage().window().setPosition(new Point(2500, 50));
    }

    @AfterEach
    public void tearDown() {
        if (driver != null) {
            driver.quit();
        }
    }

    @Test//
    @Disabled ("Тест не рабочий, т.к. нужно указывать собственный путь к собственному html файлу")
    public void testText() throws InterruptedException {
        driver.get("file:///C:/Users/Sammy/Desktop/%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0/4%20%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C/JavaLessons4Module/src/test/resources/file.html");
        WebElement webElement = driver.findElement(By.xpath("//p[text() = 'Очень вкусно.']"));
        /* Получаем id элемента, чтобы с ним взаимодействовать далее. В коде выше, мы преминили надёжной способ поиска,
        тем что привязали поиск по тексту "//p[text() = 'Очень вкусно.']"
         При поиске лучше использовать ординарные кавычки, т.к. если поставим двойные, то idea преобразит
         немного и добавит обратный слэшь. //p[text() = \"Очень вкусно.\"]" Да и ординарные, визуально лучше выглядят*/

        String actualTitle = webElement.getText();
        //                     //body/p    //p     //html/body/p    //html//p  - перечисляем способы поиска.

        /* Самый быстрый способ поиска для нас будет //p. Кроме того, чем хорош данный способ поиска //p? Допустим
        мы указали путь //html/body/p. А разработчик взял и добавил новый тег div и наш указанный нами путь
        //html/body/p ничего не найдёт */

        assertEquals("Очень вкусно.", actualTitle);
    }


    @Test
    @Disabled ("Тест не рабочий, т.к. нужно указывать собственный путь к собственному html файлу")
    public void testButton() throws InterruptedException {
        driver.get("file:///C:/Users/Sammy/Desktop/%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0/4%20%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C/JavaLessons4Module/src/test/resources/file.html");
        driver.findElement(By.xpath("//button[text() = 'Заказать']")).click();
        //                                         //button[@class = "red"]// ч/з символ @ мы можем указать любой атрибут
        // ВАЖНО!!! Вместо любого тэга мы можем в поисковой строке указать * и получится //*[@class = "red"]. Опасность
        // в том, что в html может быть несколько одинаковых классов, и в автотесте мы будем искать не тот тэг
    }
}

/*НО БЫВАЮТ СЛУЧАИ КОГДА [@class = "**********"] МЫ ПРИМЕНИТЬ НЕ МОЖЕМ, т.к. в теге может быть прописано
    сразу несколько классов, например сразу три класса в данном коде прописал фронтенд разработчик
    <a class="tm-header__logo tm-header__logo_hl-ru tm-header__logo" href="/ru/">.
    - logo tm-header,
    - logo_hl-ru tm-header
    - logo" href="
    И получается, сегодня этих классов 3, а завтра может быть 2 или 4. И тогда автотест упадёт. Такой длинный xpath
    брать не нужно. А если мы его обрезаем, то поиск не происходит. И тогда нам сможет помочь функция contains.
    Данная ФУНКЦИЯ contains ПРИНИМАЕТ ДВА аргумента. ПЕРВЫЙ это может быть как class, так и text который мы ищем,
     второй аргумент я так понял это наименование класса или сам текст.
     Так же если в коде html есть информация по id, то можно отталкиваться от него, т.к. как обычно разработчик
     на странице указывает id в основном только один раз
     Далее приведём пример поиска тега как по @class, так и contains(text(), поставив функцию and
     button[@class='tm-navigation-filters-spoiler__button' and contains(text(),'Настройки')]

     А вот следующии пример показывает как искать тег, в котором нет никакого текста b[contains(.,'Привет')].
     Здесь мы поставили в качестве первого аргумента точку. Волшебная вещь, позволяет искать текст во всех
     вложенных элементах тега b. Но не только в нём, а в любом дочернем его элементе. Расшифровывается, как
     найди мне тег b, внутри которого могут быть дочерние элементы в которых может быть текст 'Привет'
     */

    /*ОЧЕНЬ ВАЖНО!!! ПОИСК ПО Xpath ПОЗВАЛЯЕТ НАМ УКАЗАТЬ ПУТЬ НЕ ТОЛЬКО СВЕРХУ В НИЗ В НИСХОДЯЩИЕ ТЕГИ , НО И
    ОБРАТИТЬСЯ С НИЗУ ВВЕРХ В РОДИТЕЛЬСКИЙ. ДЛЯ ЭТОГО В НАЙДЕНОМ НИСХОДЯЩЕМ ТЕГЕ ПОСЛЕ СЛЭША ПИШЕМ ДВЕ ТОЧКИ
    И УКАЗЫВАЕМ РОДИТЕЛЬСКИЙ (Т.Е. ВЫШЕСТОЯШИЙ ТЭГ). И ТАК МОЖЕМ ДЕЛАТЬ ДО БЕСКОНЕЧНОСТИ, ПОКА НЕ ДАЙДЕМ ДО
    ТЭГА HTML. НО ТАК ДЕЛАТЬ НЕ НУЖНО

    ВАЖНО!!! Чтобы не держать в голове все примочки xpath, есть куча сайтов, где приведена данная информация
    в виде шпаргалок. Например, https://devhints.io/xpath

    Итак, если обобщать, то из минусов, что xpath очень объемный. Из плюсов, что мы можем ходить вверх вниз по дереву,
    а также влево и вправо. И даже ходить от соседа к соседу. Можно работать с числами

    ******************************CSS селекторы*********************************
    Здесь, чтобы найти класс, мы просто в поисковой строке указываем название тега через точку, например .red.
    Ну а чтобы найти тег, просто пишем его наименование, например p. Выше мы искали логотип habr через xpath.
    Далее можно привести пример поиска того же логотипа, но через селектор
    span[class *= 'logo-wrap'] > a[href='/ru/'] - селектор для логотипа Хабра
    Здесь, как в xpath не ставим @, а просто пишем class. Знак > позволяет опуститься к элементу ниже.
    Эсли хотим найти элемент по id, то мы сразу говорим, #mount. Где, mount это название класса.

    В презентации к данному уроку, приведён хороший слайд (№15) с примером сравнения CSS и xpath. Другие слайды тоже
    будут полезны для работы

    На прошлом занятии учились как найти элемент findElement, а на этом занятии рассмотрим, что с этим элементом
    можно делать
    */